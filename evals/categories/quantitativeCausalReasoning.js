/**
 * This is the quantitative causal reasoning test
 * 
 * The quantitative causal reasoning evaluation category tests whether quantitative models generated by LLMs 
 * include key processes and causal mechanisms that domain experts consider essential for 
 * understanding a particular system. Unlike other evaluation categories that focus on structural 
 * accuracy or conformance to instructions, this category evaluates the substantive quality 
 * of the causal reasoning embedded in generated models.
 *
 * The evaluation works by providing the LLM with expert knowledge about a domain, then checking 
 * whether the generated quantitative model includes specific stocks, flows, and causal relationships 
 * that experts have identified as critical to understanding the system's behavior. This allows us 
 * to assess not just whether the model is structurally correct, but whether it captures the 
 * essential causal logic that makes it useful for policy analysis and decision-making.
 * 
 * @module categories/quantitativeCausalReasoning
 */

// Note: pluralize import removed as it's not used in this evaluation

/** generic prompt used for all tests */
const prompt = "Please give me a quantitative model that captures the key causal processes described in the background information.";
/** generic problem statement used for all tests */
const problemStatement = "I'm trying to understand the key causal mechanisms that drive this system's behavior over time.";

/**
 * Generates a test case with expert knowledge and expected causal processes
 * @param {string} name Test name
 * @param {string} timeUnit Time units for the model (e.g., "month", "year")
 * @param {string} backgroundKnowledge Expert description of the system
 * @param {Array} expectedProcesses List of key processes that should be present
 * @returns {Object} Test case with prompt, parameters, and expectations
 */
/**
 * Normalizes a variable name for case-insensitive and whitespace/underscore-insensitive comparison
 * @param {string} name The variable name to normalize
 * @returns {string} Normalized name (lowercase, spaces and underscores removed)
 */
const normalizeVariableName = function(name) {
    return name.toLowerCase().replace(/[\s_-]/g, '');
};

/**
 * Checks if a variable name matches the expected name using flexible matching
 * @param {string} variableName The variable name from the generated model
 * @param {string} expectedName The expected variable name
 * @returns {boolean} True if names match
 */
const variableNameMatches = function(variableName, expectedName) {
    const normalizedVariable = normalizeVariableName(variableName);
    const normalizedExpected = normalizeVariableName(expectedName);
    return normalizedVariable.includes(normalizedExpected) || normalizedExpected.includes(normalizedVariable);
};

const generateTest = function(name, timeUnit, backgroundKnowledge, expectedProcesses) {
    return {
        name: name,
        prompt: prompt,
        additionalParameters: {
            problemStatement: problemStatement,
            backgroundKnowledge: backgroundKnowledge
        },
        expectations: {
            timeUnit: timeUnit,
            expectedProcesses: expectedProcesses
        }
    };
};

/**
 * Checks if a process is represented in the generated model
 * @param {Object} process Expected process definition
 * @param {Object} generatedModel The model generated by the LLM
 * @returns {boolean} True if the process is adequately represented
 */
const processIsPresent = function(process, generatedModel) {
    const variables = generatedModel.variables || [];
    const relationships = generatedModel.relationships || [];
    
    // Check if required stocks are present (require 100% match)
    if (process.requiredStocks) {
        for (const stockName of process.requiredStocks) {
            const stock = variables.find(v => 
                v.type === 'stock' && 
                variableNameMatches(v.name, stockName)
            );
            if (!stock) {
                return false;
            }
        }
    }
    
    // Check if required flows are present (require 100% match)
    if (process.requiredFlows) {
        for (const flowName of process.requiredFlows) {
            const flow = variables.find(v => 
                v.type === 'flow' && 
                variableNameMatches(v.name, flowName)
            );
            if (!flow) {
                return false;
            }
        }
    }
    
    // Check if required relationships are present (focus on key causal patterns with flexible variable matching)
    if (process.requiredRelationships) {
        for (const reqRel of process.requiredRelationships) {
            const relationshipExists = relationships.some(rel => {
                const fromMatches = variables.some(v => variableNameMatches(v.name, reqRel.from) && variableNameMatches(rel.from, v.name));
                const toMatches = variables.some(v => variableNameMatches(v.name, reqRel.to) && variableNameMatches(rel.to, v.name));
                const polarityMatches = !reqRel.polarity || rel.polarity === reqRel.polarity;
                return fromMatches && toMatches && polarityMatches;
            });
            if (!relationshipExists) {
                return false;
            }
        }
    }
    
    // Check if required variables with specific types are present (require 100% match)
    if (process.requiredVariables) {
        for (const keyVar of process.requiredVariables) {
            const variable = variables.find(v => {
                const nameMatches = variableNameMatches(v.name, keyVar.name);
                const typeMatches = !keyVar.type || v.type === keyVar.type;
                return nameMatches && typeMatches;
            });
            if (!variable) {
                return false;
            }
        }
    }
    
    return true;
};

/**
 * This method compares the generated response to the ground truth and returns a list of failure objects
 * @param {Object} generatedResponse The response from the engine
 * @param {Object} expectations The expected processes and time unit information
 * @returns {Array<Object>} A list of failures with type and details.
 */
export const evaluate = function(generatedResponse, expectations) {
    const generatedModel = generatedResponse?.model || {};
    const expectedProcesses = expectations.expectedProcesses || [];
    const failures = [];

    // Check if the model has basic quantitative structure
    const variables = generatedModel.variables || [];
    const stocks = variables.filter(v => v.type === 'stock');
    const flows = variables.filter(v => v.type === 'flow');
    
    if (stocks.length === 0) {
        failures.push({
            type: "No stocks found",
            details: "A quantitative model should contain at least one stock variable"
        });
    }
    
    if (flows.length === 0) {
        failures.push({
            type: "No flows found", 
            details: "A quantitative model should contain at least one flow variable"
        });
    }

    // Check time units if specified
    if (expectations.timeUnit) {
        const modelTimeUnit = generatedModel.specs?.timeUnits;
        if (!modelTimeUnit || !modelTimeUnit.toLowerCase().includes(expectations.timeUnit.toLowerCase())) {
            failures.push({
                type: "Incorrect time unit",
                details: `Expected time unit to include "${expectations.timeUnit}", found "${modelTimeUnit || 'undefined'}"`
            });
        }
    }

    // Check each expected process
    for (const process of expectedProcesses) {
        if (!processIsPresent(process, generatedModel)) {
            const missingElements = [];
            const relationships = generatedModel.relationships || [];
            
            // Identify what's missing
            if (process.requiredStocks) {
                const missingStocks = process.requiredStocks.filter(stockName => 
                    !variables.some(v => v.type === 'stock' && variableNameMatches(v.name, stockName))
                );
                if (missingStocks.length > 0) {
                    missingElements.push(`stocks: ${missingStocks.join(', ')}`);
                }
            }
            
            if (process.requiredFlows) {
                const missingFlows = process.requiredFlows.filter(flowName =>
                    !variables.some(v => v.type === 'flow' && variableNameMatches(v.name, flowName))
                );
                if (missingFlows.length > 0) {
                    missingElements.push(`flows: ${missingFlows.join(', ')}`);
                }
            }
            
            if (process.requiredRelationships) {
                const missingRelationships = process.requiredRelationships.filter(reqRel => {
                    return !relationships.some(rel => {
                        const fromMatches = variables.some(v => variableNameMatches(v.name, reqRel.from) && variableNameMatches(rel.from, v.name));
                        const toMatches = variables.some(v => variableNameMatches(v.name, reqRel.to) && variableNameMatches(rel.to, v.name));
                        const polarityMatches = !reqRel.polarity || rel.polarity === reqRel.polarity;
                        return fromMatches && toMatches && polarityMatches;
                    });
                });
                if (missingRelationships.length > 0) {
                    const relStrings = missingRelationships.map(rel => 
                        `${rel.from} â†’ ${rel.to}${rel.polarity ? ` (${rel.polarity})` : ''}`
                    );
                    missingElements.push(`relationships: ${relStrings.join(', ')}`);
                }
            }
            
            if (process.requiredVariables) {
                const missingVars = process.requiredVariables.filter(keyVar =>
                    !variables.some(v => {
                        const nameMatches = variableNameMatches(v.name, keyVar.name);
                        const typeMatches = !keyVar.type || v.type === keyVar.type;
                        return nameMatches && typeMatches;
                    })
                );
                if (missingVars.length > 0) {
                    missingElements.push(`variables: ${missingVars.map(v => v.name).join(', ')}`);
                }
            }

            // If no specific missing elements identified, report that process requirements are not satisfied
            // This should theoretically never happen if processIsPresent logic matches error detection logic
            if (missingElements.length === 0) {
                missingElements.push(`process requirements not satisfied (unable to identify specific missing elements)`);
            }

            failures.push({
                type: "Missing key process",
                details: `Process "${process.name}" is not adequately represented. Missing: ${missingElements.join('; ')}`
            });
        }
    }

    return failures;
};

/**
 * The groups of tests to be evaluated as a part of this category
 */
export const groups = {
    "publicHealth": [
        generateTest(
            "Epidemic spread model with key epidemiological processes",
            "day",
            `Epidemiologists understand that infectious disease spread follows well-established patterns that typically evolve over daily intervals. 
            The susceptible population becomes exposed when they come into contact with infectious individuals. 
            After an incubation period, exposed individuals become infectious and can transmit the disease. 
            Infectious individuals then recover and develop immunity, or in some cases may die from the disease.
            The basic reproduction number (R0) determines how many new infections each infectious person generates.
            Public health interventions like vaccination can move people directly from susceptible to recovered,
            while social distancing measures reduce the contact rate between infectious and susceptible individuals.
            Contact tracing and quarantine can remove exposed individuals from circulation before they become infectious.
            Disease progression involves distinct compartments of people moving through the infection cycle.
            
            Use these variable names: 
            susceptible, exposed, infectious, recovered, infecting, incubating, recovering, contact rate`,
            [
                {
                    name: "SEIR disease progression",
                    requiredStocks: ["susceptible", "exposed", "infectious", "recovered"],
                    requiredFlows: ["infecting", "incubating", "recovering"],
                },
                {
                    name: "Public health interventions",
                    requiredVariables: [
                        { name: "vaccination" },
                        { name: "contacts" }
                    ],
                    requiredRelationships: [
                        { from: "contacts", to: "infecting", polarity: "+" }
                    ]
                }
            ]
        ),
        generateTest(
            "Healthcare capacity model with resource constraints",
            "week",
            `Healthcare systems have limited capacity that affects patient outcomes during health crises that unfold over weekly cycles.
            Patients requiring care enter the system through admissions, but bed capacity limits how many can be treated.
            When demand exceeds capacity, patients face delays or are turned away, potentially worsening their condition.
            Healthcare workers are the key resource - they can treat patients but also become sick themselves,
            reducing available capacity. Staff burnout increases when workload is high, leading to turnover.
            Hospitals can surge capacity by opening additional beds and hiring temporary staff, but this takes time.
            Recovery times vary - some patients recover quickly while others require long-term care.
            The system involves managing patient flows, workforce dynamics, and available bed resources.
            
            Use these variable names: 
            patients, available beds, healthcare workers, workload, burnout.`,
            [
                {
                    name: "Hospital capacity management",
                    requiredStocks: ["patients", "available beds", "healthcare workers"],
                },
                {
                    name: "Staff burnout dynamics",
                    requiredVariables: [
                        { name: "workload", type: "variable" },
                        { name: "burnout", type: "variable" }
                    ],
                    requiredRelationships: [
                        { from: "patients", to: "workload", polarity: "+" },
                        { from: "workload", to: "burnout", polarity: "+" },
                        { from: "burnout", to: "staff turnover", polarity: "+" }
                    ]
                }
            ]
        )
    ],
    "urbanPlanning": [
        generateTest(
            "Traffic congestion model with induced demand",
            "year",
            `Transportation engineers recognize that building more roads often fails to reduce congestion due to induced demand effects that emerge over annual planning cycles.
            When new road capacity is added, it initially reduces travel time and congestion. However, this improvement
            attracts new drivers who switch from other routes, times, or modes of transport. Some people who previously
            didn't make trips now find driving more attractive. Over time, this increased traffic volume can return
            congestion to previous levels or even make it worse. The phenomenon demonstrates that transportation is not
            just about moving vehicles, but about the complex behavioral responses to changes in the system.
            Traffic also creates negative externalities like air pollution and noise, which affect quality of life.
            The system involves road infrastructure, traveler behavior, and traffic volume dynamics.
            
            Use these variable names: 
            road capacity, travelers, travel time, congestion.`,
            [
                {
                    name: "Induced demand mechanism",
                    requiredStocks: ["road capacity", "travelers"],
                },
                {
                    name: "Congestion feedback loop",
                    requiredVariables: [
                        { name: "travel time", type: "variable" },
                        { name: "congestion", type: "variable" }
                    ]
                }
            ]
        ),
    ]
};